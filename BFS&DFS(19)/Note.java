DFS O(O(2^n), O(n!)) （思想：构建搜索树 + 判断可行性）
    1. Find all possible solutions
    2. Permutations / Subsets

BFS O(O(m), O(n))
    1. Graph traversal(每个点只遍历一次)
    2. Find shortest path in a simple graph
